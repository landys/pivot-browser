<?xml version="1.0" encoding="utf-8"?>
<mx:Canvas xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:hisa="*"
	width="100%" height="100%"
	creationComplete="initApp()">
	<mx:Script>
		<![CDATA[
			import hisa.event.ClusterClickEvent;
			import mx.events.ItemClickEvent;
			import mx.rpc.events.ResultEvent;
			import mx.collections.ArrayCollection;
			import mx.events.DragEvent;
			import mx.events.EffectEvent;
			import mx.managers.DragManager;
			import mx.core.*;
			import mx.controls.*;
			import mx.effects.*;
			import mx.rpc.events.FaultEvent;
			import mx.events.CloseEvent;

			
			[Embed(source="assets/icon_left.png")]
			private const ICON_LEFT:Class;
			
			[Embed(source="assets/icon_right.png")]		
			private const ICON_RIGHT:Class;
			
			[Embed(source="assets/icon_left_disabled.png")]
			private const ICON_LEFT_DISABLED:Class;
			
			[Embed(source="assets/icon_right_disabled.png")]
			private const ICON_RIGHT_DISABLED:Class;

			private var tagsSearched:ArrayCollection = new ArrayCollection();
			
			// size of each cluster
			private var sCluster:Object = {w:190, h:112};
			
			// shape of all clusters
			[Bindable]
			private var sCls:ArrayCollection = new ArrayCollection(
				[{x:26, y:80, w:sCluster.w, h:sCluster.h},
				{x:228, y:80, w:sCluster.w, h:sCluster.h},
				{x:430, y:80, w:sCluster.w, h:sCluster.h},
				{x:632, y:80, w:sCluster.w, h:sCluster.h},
				{x:834, y:80, w:sCluster.w, h:sCluster.h},
				{x:-176, y:80, w:sCluster.w, h:sCluster.h}]);
			
			// x interval of two clusters.
			private static const interval:int = 202;
			
			// shape of all HRules
			[Bindable]
			private var sHrs:ArrayCollection = new ArrayCollection(
				[{x:sCls[0].x+sCluster.w/2, y:sCls[0].y+5, w:200, h:2, r:-10},
				{x:sCls[1].x+sCluster.w/2, y:sCls[1].y+5, w:100, h:2, r:-30},
				{x:sCls[2].x+sCluster.w/2, y:sCls[2].y+5, w:100, h:2, r:-150},
				{x:sCls[3].x+sCluster.w/2, y:sCls[3].y+5, w:200, h:2, r:-170}]);
				
			// the size of beginning center cluster	
			private var sClCenter:Object = {x:200, y:18, w:420, h:166}; 
			
			// the size of center cluster
			//private var sClC:Object = {x:258, y:74, w:140, h:70}; 
			private var sClC:Object = {x:sClCenter.x, y:5, w:sClCenter.w, h:53}; 
			
			// place of center of clusters, one endpoint of the Hrs.
			private var pCenter:Object = {x:sClC.x+sClC.w/2, y:sClC.y+sClC.h/2};
			
			// begin, only one cluster
			private var isOnly:Boolean;
			
			// check is bigger
			private var iBigger:int;
			
			// all clusters in total
			private var clusters:ArrayCollection;
			
			// the current move position of clusters.
			private var curPosition:int = 0;
			
			// effects
			private var parShowAll:Parallel;
			
			// horizontal move left
			private var parMoveLeft:Parallel;
			
			// horizontal move right
			private var parMoveRight:Parallel;
			
			// most number of clusters on the screen
			private var ncMost:int = 4;
			
			// number of clusters, including 2 hidden clusters
			private var ncAll:int = ncMost + 2;
			
			// all clusters related to center tag
			// it must be assigned every change
			private var ncReal:int;
			
			// page of pictures
			private var picPage:int;
			
			// the cluster for search pictures
			private var selectedClusterIndex:int;
			
			private var selectedPic:String;
			
			// used only in delection
			private var tempTag:String;
			
			[Bindable]
			private var topKInSelectTag:int = 100;
			
			[Bindable]
			private var maxClusterNum:int = 20;
			
			[Bindable]
			private var isExpansion:Boolean = true;
			
			[Bindable]
			private var isCluster:Boolean = true; 
			
			// the count of processing remote call
			private var remoteCallCount:int = 0;
			
			private function initApp():void
			{
				//Security.loadPolicyFile("http://192.168.80.158:8080/PivotBrowser/crossdomain.xml");
				
				//trace("SearchView.initApp() begin.");
				searchRO.getPicUrlForTagsRank.addEventListener("result", getPicUrlForTagsRankHandler);
				searchRO.getPicUrlForTagsRank.addEventListener("fault", faultHandler);
				searchRO.getPicUrlForColorRank.addEventListener("result", getPicUrlForColorRankHandler);
				searchRO.getPicUrlForColorRank.addEventListener("fault", faultHandler);
				searchRO.getPicUrlForWaveLetRank.addEventListener("result", getPicUrlForWaveLetRankHandler);
				searchRO.getPicUrlForWaveLetRank.addEventListener("fault", faultHandler);
				searchRO.getPicUrlForTagsRandom.addEventListener("result", getPicUrlForTagsRandomHandler);
				searchRO.getPicUrlForTagsRandom.addEventListener("fault", faultHandler);
				searchRO.getTagCloud.addEventListener("result", getTagCloudHandler);
				searchRO.getTagCloud.addEventListener("fault", faultHandler);
				searchRO.searchTag.addEventListener("result", searchTagHandler);
				searchRO.searchTag.addEventListener("fault", faultHandler);
				
				// create effects
				parShowAll = new Parallel();
				parMoveLeft = new Parallel();
				parMoveRight = new Parallel();
				
				// create effects for each clusters and rules
				for (var i:int=0; i<cls.length; i++)
				{
					var par:Parallel = new Parallel();
					// cluster effect
					var res:Resize = new Resize(cls[i]);
					var mov:Move = new Move(cls[i]);
					
					res.widthFrom = 1;
					res.widthTo = sCls[i].w;
					res.heightFrom = 1;
					res.heightTo = sCls[i].h;
					mov.xFrom = pCenter.x;
					mov.xTo = sCls[i].x;
					mov.yFrom = pCenter.y;
					mov.yTo = sCls[i].y;
					
					par.addChild(res);
					par.addChild(mov);
					
					// hrule effect
					if (i < sHrs.length)
					{
						res = new Resize(hrs[i]);
						mov = new Move(hrs[i]);
						
						res.widthFrom = 1;
						res.widthTo = sHrs[i].w;
						res.heightFrom = 1;
						res.heightTo = sHrs[i].h;
						mov.xFrom = pCenter.x;
						mov.xTo = sHrs[i].x;
						mov.yFrom = pCenter.y;
						mov.yTo = sHrs[i].y;
						
						par.addChild(res);
						par.addChild(mov);
					}
					
					// add to all effect
					parShowAll.addChild(par);
					
					// horizontal move left
					var movLeft:Move = new Move(cls[i]);
					movLeft.xBy = -interval;
					parMoveLeft.addChild(movLeft);
					
					// horizontal move right
					var movRight:Move = new Move(cls[i]);
					movRight.xBy = interval;
					parMoveRight.addChild(movRight);
				}
				
				parShowAll.addEventListener(EffectEvent.EFFECT_START, setAllVisible);
				parMoveLeft.addEventListener(EffectEvent.EFFECT_END, onMoveLeftDone);
				parMoveRight.addEventListener(EffectEvent.EFFECT_END, onMoveRightDone);
				
				gameStart();
				
				//trace("SearchView.initApp() end");
			}
			
			private function gameStart():void
			{
				setAllNotVisible();
				// init cluster center				
				clusCenter.x = sClCenter.x;
				clusCenter.y = sClCenter.y;
				clusCenter.width = sClCenter.w;
				clusCenter.height = sClCenter.h;
				
				isOnly = true;
				iBigger = -1;
				ncReal = 0;
				picPage = 0;
				selectedPic = "";
				tagsSearched.removeAll();
				setAllRadio(false);
				navPrevClus.visible = false;
				navNextClus.visible = false;
				clusCenter.setStyleName("clusterCanvas");
				cls[selectedClusterIndex].setStyleName("clusterCanvas");
				clsWhole.setStyleName("clusterCanvasWhole");
				selectedClusterIndex = 0;
				
				searchRO.getTagCloud(20);
				disableApplication();
			}
			
			private function disableApplication():void
			{
				++remoteCallCount;
				Application.application.enabled = false;
			}
			
			private function enableApplication():void
			{
				if (--remoteCallCount <= 0)
				{
					Application.application.enabled = true;
				}
			}
			
			private function setAllNotVisible():void
			{
				//trace("SearchView.setAllNotVisible() begin");
				for (var i:int=0; i<ncAll; i++)
				{
					cls[i].visible = false;
					if (i < hrs.length)
					{
						hrs[i].visible = false;
					}
				}
			}
			
			private function setAllVisible(event:EffectEvent):void
			{
				//trace("SearchView.setAllVisible() begin");
				for (var i:int=0; i<ncReal&&i<ncMost; i++)
				{
					cls[i].visible = true;
					hrs[i].visible = true;
				}
			}
			
			private function onMoveLeftDone(event:EffectEvent):void
			{
				var leftestIndex:int = calcLeftestIndex();
				var rightestIndex:int = calcRightestIndex();
				
				cls[leftestIndex].visible = false;
				
				assignCluster(rightestIndex);
				cls[rightestIndex].x = sCls[ncMost].x;
				cls[rightestIndex].y = sCls[ncMost].y;
				
				if (selectedClusterIndex == leftestIndex)
				{
					doSearchClusters(calcLeftestVisibleIndex());
				}
			}
			
			private function onMoveRightDone(event:EffectEvent):void
			{
				var leftestIndex:int = calcLeftestIndex();
				var rightestIndex:int = calcRightestIndex();
				
				cls[rightestIndex].visible = false;

				assignCluster(leftestIndex);
				cls[leftestIndex].x = sCls[ncMost+1].x;
				cls[leftestIndex].y = sCls[ncMost+1].y;
				
				if (selectedClusterIndex == rightestIndex)
				{
					doSearchClusters(calcRightestVisibleIndex());
				}
			}
			
			// view a tag and its relative clusters
			public function viewTag(tag:String, index:int):void
			{
				var tags:Array = [tag];
				viewTags(tags, index);
			}
			
			private function setAllRadio(flag:Boolean):void
			{
				rbtnColor.enabled = flag;
				rbtnColor.selected = flag;
				rbtnWavelet.enabled = flag;
				rbtnWavelet.selected = flag;	
				rbtnRandom.enabled = flag;
				rbtnRandom.selected = flag;
			}
			
			private function alertClickHandler(event:CloseEvent):void {
                if (event.detail == Alert.YES)
                {
                    tagsSearched.removeItemAt(tagsSearched.getItemIndex(tempTag));
					if (tagsSearched.length == 0)
					{
						gameStart();
					}
					else
					{
						doViewTags();
					}
                }
            }

			public function viewTags(tags:Array, index:int):void
			{
				//trace("SearchView.viewTag(tag:String="+tag+", index:int="+index+") begin");		
				if (index == 6 && !isOnly && tags.length == 1 && tagsSearched.contains(tags[0]))
				{
					// delete tags
					tempTag = tags[0];
					Alert.show("Delete the tag \"" + tags[0] + "\"?", "Delete Confirm", Alert.YES | Alert.NO, this, alertClickHandler);
					return;
				}
				else
				{
					for (var i:int=0; i<tags.length; i++)
					{
						if (!tagsSearched.contains(tags[i]))
						{
							tagsSearched.addItem(tags[i]);
						}
					}
				}	
				
				doViewTags();
				
				//trace("SearchView.viewTag(tag:String, index:int) end");
			}
			
			private function doViewTags():void
			{
				setAllNotVisible();
				
				setAllRadio(false);
				
				// make center tag visible
				//clusCenter.visible = false;
				if (isOnly || iBigger == clusCenter.index)
				{
					clusCenter.width = sClC.w;
					clusCenter.height = sClC.h;
					clusCenter.x = sClC.x;
					clusCenter.y = sClC.y;
					clusCenter.styleName = "clusterCanvasCircle";
					clusCenter.tags = tagsSearched;
				}
				
				if (selectedClusterIndex != 0)
				{
					cls[selectedClusterIndex].setStyleName("clusterCanvas");
					selectedClusterIndex = 0;
				}
				cls[0].setStyleName("clusterCanvasPicked");		
				
				if (tagsSearched.length > 0)
				{
					topKInSelectTag = (int)(txtTopKInSelectTag.text);
					if (topKInSelectTag == 0)
					{
						topKInSelectTag = 100;
					}
					maxClusterNum = (int)(txtMaxClusterNum.text);
					if (maxClusterNum == 0)
					{
						maxClusterNum = 100;
					}
					isExpansion = chkIsExpansion.selected;
					isCluster = chkIsCluster.selected;
					navPrevClus.visible = false;
					navNextClus.visible = false;
					setAllNotVisible();
					searchRO.searchTag(tagsSearched, topKInSelectTag, maxClusterNum, isExpansion, isCluster);
					disableApplication();
				}
			}
         
            //Function called by the canvas dragEnter event; enables dropping
			private function doDragEnter(event:DragEvent):void 
			{
				trace("SearchView.doDragEnter(event:DragEvent) begin");
				if (event.dragSource.hasFormat("img"))
	            {
	                DragManager.acceptDragDrop(IUIComponent(event.target));
	            }
			}

			private function doDragDrop(event:DragEvent):void 
			{
				//trace("SearchView.doDragDrop(event:DragEvent) begin");
				if (imgSelected.blendMode != BlendMode.NORMAL)
				{
					imgSelected.blendMode = BlendMode.NORMAL;
				}
				var img:Image = event.dragSource.dataForFormat("img") as Image;
				selectedPic = event.dragSource.dataForFormat("imgUrl") as String;
				imgSelected.source = img.source;
				//imgSelected.toolTip = selectedPic;
				rbtnColor.enabled = true;
				rbtnWavelet.enabled = true;
				rbtnRandom.enabled = true;
				rbtnColor.selected = true;
				
				picPage = 0;
				searchRO.getPicUrlForColorRank(null, picPage, selectedPic);
				disableApplication();
			}
			
			private function doResize(resize:Parallel):void
			{
				////trace("SearchView.doResize(resize:Parallel) begin");
				resize.end();
				resize.play();
			}
			
			public function showBiggerCluster(index:int):void
			{		
				//trace("SearchView.showBiggerCluster(index:int="+index+") begin");	
				if (isOnly)
				{
					moveExClusBig.xTo = 0;
					moveExClusBig.yTo = 0;
					resExClusBig.widthTo = canCluster.width;
					resExClusBig.heightTo = canCluster.height;
					expandClusBig.target = clusCenter;
					iBigger = index;
					doResize(expandClusBig);
					return;
				}
				
				var ci:TagCluster = ((index>=0 && index<=5) ? cls[index] : clusCenter);
				if (iBigger == -1 || iBigger != index)
				{
					var xBy:int = 0;
					var yBy:int = 0;
					var widthTo:int = sCluster.w * 2;
					var heightTo:int = sCluster.h * 2;
					switch (index)
					{
					case 0:
						break;
					case 1:
						xBy = ci.width - widthTo;
						break;
					case 2:
						yBy = ci.height - heightTo;
						break;
					case 3:
						xBy = ci.width - widthTo;
						yBy = ci.height - heightTo;
						break;
					case 4:
						yBy = (ci.height - heightTo) / 2;
						break;
					case 5:
						xBy = ci.width - widthTo;
						yBy = (ci.height - heightTo) / 2;
						break;					
					case 6:
						xBy = (ci.width - widthTo) / 2;
						yBy = (ci.height - heightTo) / 2;
						break;
					default:
						return;
					}
					
					resExClusBig.widthTo = widthTo;
					resExClusBig.heightTo = heightTo;
					moveExClusBig.xTo = ci.x + xBy;
					moveExClusBig.yTo = ci.y + yBy;
					
					expandClusBig.target = ci;
					// change z-order of cls[index]
					canCluster.removeChild(ci);
					canCluster.addChild(ci);

					if (iBigger != -1)
					{
						showSmallerCluster(iBigger);
					}
				}
				else
				{
					moveExClusBig.xTo = 0;
					moveExClusBig.yTo = 0;
					resExClusBig.widthTo = canCluster.width;
					resExClusBig.heightTo = canCluster.height;
					expandClusBig.target = ci;
				}
				
				iBigger = index;
				doResize(expandClusBig);
				//trace("SearchView.showBiggerCluster(index:int) end");
			}
			
			public function showSmallerCluster(index:int=-1):void
			{
				//trace("SearchView.showSmallerCluster(index:int="+index+") begin");
				
				var ic:int = (index == -1 ? iBigger : index);

				if (ic != -1)
				{
					if (isOnly)
					{
						moveConClusBig.xTo = sClCenter.x;
						moveConClusBig.yTo = sClCenter.y;
						resConClusBig.widthTo = sClCenter.w;
						resConClusBig.heightTo = sClCenter.h;
						contractClusBig.target = clusCenter;
					}
					else 
					{
						var cb:TagCluster;
						var scb:Object;
						if (ic >= 0 && ic <= 5)
						{
							cb = cls[ic];
							scb = sCls[ic];
						}
						else
						{
							cb = clusCenter;
							scb = sClC;
						}
						// contact the bigger one first
						moveConClusBig.xTo = scb.x;
						moveConClusBig.yTo = scb.y;
						resConClusBig.widthTo = scb.w;
						resConClusBig.heightTo = scb.h;
						contractClusBig.target = cb;
					}
					doResize(contractClusBig);
					if (index == -1)
					{
						iBigger = -1;
					}
				}
				
				doSearchClusters(index);
				//trace("SearchView.showSmallerCluster(index:int) end");
			}
			
			private function doSearchClusters(index:int=-1):void
			{
				if (index >=0 && index <=5)
				{
					// get pictures
					picPage = 0;
					searchRO.getPicUrlForTagsRandom(getTagNames(clusters[calcDataIndex(index)].tagList), tagsSearched, picPage);		
					disableApplication();
					rbtnColor.enabled = false;
					rbtnWavelet.enabled = false;
					rbtnColor.selected = false;
					rbtnWavelet.selected = false;
					rbtnRandom.enabled = false;
					rbtnRandom.selected = false;
					
					if (selectedClusterIndex != index)
					{
						cls[selectedClusterIndex].setStyleName("clusterCanvas");
						cls[index].setStyleName("clusterCanvasPicked");
						selectedClusterIndex = index;
						clsWhole.tags = cls[selectedClusterIndex].tags;
						clsWhole.pics = cls[selectedClusterIndex].pics;
					}
				}
			}
			
			// calculate the cluster data index from the cluster index.
			private function calcDataIndex(index:int):int
			{
				return Math.floor((curPosition + 2 * ncAll - 2 - index) / ncAll - 1) * ncAll + index;
			}
			
			// calculate the index of leftest cluster
			private function calcLeftestIndex():int
			{
				return (curPosition + ncAll - 1) % 6;
			}
			
			// calculate the index of rightest cluster
			private function calcRightestIndex():int
			{
				return (curPosition + ncAll - 2) % 6;
			}
			
			// calculate the index of leftest visible cluster
			private function calcLeftestVisibleIndex():int
			{
				return curPosition % 6;
			}
			
			// calculate the index of rightest visible cluster
			private function calcRightestVisibleIndex():int
			{
				return (curPosition + ncMost - 1) % 6;
			}
			
			private function faultHandler(event:FaultEvent):void
			{
				Alert.show("fault: "+event.message);			
				enableApplication();
				//trace("fault: "+event.message);
			}
			
			private function getPicUrlForTagsRankHandler(event:ResultEvent):void
			{
				//trace("SearchView.getPicUrlForTagsHandler(event:ResultEvent) begin");
				var a:ArrayCollection = ArrayCollection(event.result);
				//inputTag.text = a[0];
				
				var photos:ArrayCollection = new ArrayCollection();
				var i:int;
				if (tagsSearched != null && tagsSearched.length > 0)
				{
					var toolTip:String = "Tags: ";
					toolTip += tagsSearched[0];
					for (i=1; i<tagsSearched.length && i<3; i++)
					{
						toolTip += ", " + tagsSearched[i];
					}
					if (tagsSearched.length > 3)
					{
						toolTip += ", ...";
					}
				}
				
				for (i=0; i<a.length; i++)
				{	
					photos.addItem({source: a.getItemAt(i), toolTip: toolTip});
				}
				
				imgView.photos = photos;
				
				enableApplication();
				
				//trace("SearchView.getPicUrlForTagsHandler(event:ResultEvent) ends");
			}
			
			private function getPicUrlForColorRankHandler(event:ResultEvent):void
			{
				//trace("SearchView.getPicUrlForColorRankHandler(event:ResultEvent) begin");
				getPicUrlForTagsRankHandler(event);
			}
			
			private function getPicUrlForWaveLetRankHandler(event:ResultEvent):void
			{
				//trace("SearchView.getPicUrlForWaveLetRankHandler(event:ResultEvent) begin");
				getPicUrlForTagsRankHandler(event);
			}
			
			private function getPicUrlForTagsRandomHandler(event:ResultEvent):void
			{
				//trace("SearchView.getPicUrlForTagsRandomHandler(event:ResultEvent) begin");
				getPicUrlForTagsRankHandler(event);		
			}
			
			private function getTagCloudHandler(event:ResultEvent):void
			{
				//trace("SearchView.getTagCloudHandler(event:ResultEvent) begin");
				var tagsCenter:ArrayCollection = new ArrayCollection();
				var a:ArrayCollection = ArrayCollection(event.result);
				for (var i:int=0; i<a.length; i++)
				{
					tagsCenter.addItem({label: a[i].tagName});
				}
				clusCenter.tags = tagsCenter;
				dissolveIn.end();
				dissolveIn.play();
				
				enableApplication();
				//trace("SearchView.getTagCloudHandler(event:ResultEvent) end");
			}
			
			private function searchTagHandler(event:ResultEvent):void
			{
				//trace("SearchView.searchTagHandler(event:ResultEvent) begin");
				clusters = ArrayCollection(event.result);
				curPosition = 0;
				
				assignClusPage();	
				
				if (cls[0].tags != null)
				{
					searchRO.getPicUrlForTagsRandom(getTagNames(clusters[calcDataIndex(0)].tagList), tagsSearched, picPage);
					disableApplication();
				}
				// layout tags in center cluster
				var temp:ArrayCollection = new ArrayCollection();
				for (var i:int=0; i<tagsSearched.length; i++)
				{
					temp.addItem({label: tagsSearched[i]});
				}
				clusCenter.tags = temp;
				//clusCenter.visible = true;
				
				dissolveIn.end();
				dissolveIn.play();
				
				// play effect
				parShowAll.end();
				parShowAll.play();
				
				// make not isOnly
				isOnly = false;
				iBigger = -1;
				
				navPrevClus.visible = false;
				if (clusters.length > ncMost)
				{
					navNextClus.visible = true;	
				}
				else
				{
					navNextClus.visible = false;
				}
								
				enableApplication();
				//trace("SearchView.searchTagHandler(event:ResultEvent) end");
			}
			
			private function assignCluster(index:int):void
			{		
				var dataIndex:int = calcDataIndex(index);
				if (dataIndex >= clusters.length || dataIndex < 0)
				{
					return;
				}
				
				var tempb:ArrayCollection = new ArrayCollection();
				var tempc:ArrayCollection = new ArrayCollection();
				var b:ArrayCollection = ArrayCollection(clusters[dataIndex].tagList);
				var c:ArrayCollection = ArrayCollection(clusters[dataIndex].picUrlList);
				var j:int = 0;
				if (b != null) 
				{
					for (j=0; j<b.length; j++)
					{
						tempb.addItem({label: b[j].tagName});
					}
				}
				if (c != null)
				{
					for (j=0; j<c.length; j++)
					{
						tempc.addItem(c[j]);
					}
				}
				/*
				if (tempc.length == 0) {
					tempc.addItem("assets/mondorana.jpg");
					tempc.addItem("assets/mondorana.jpg");
					tempc.addItem("assets/mondorana.jpg");
				}
				*/
				cls[index].tags = tempb;
				cls[index].pics = tempc;
			}
			
			// maybe something wrong
			private function assignClusPage():void
			{
				var len:int = clusters.length - curPosition;
				ncReal = len <= ncAll ? len : ncAll;

				for (var i:int=0; i<ncReal; i++)
				{
					assignCluster(i);
				}
				
				clsWhole.tags = cls[calcLeftestVisibleIndex()].tags;
				clsWhole.pics = cls[calcLeftestVisibleIndex()].pics;
			}
			
			private function layoutAllClusters():void
			{
				// play effect
				parShowAll.end();
				parShowAll.play();
			}
			
			private function showPrevClusPage():void
			{
				//trace("SearchView.showPrevClusPage() begin");
				//trace("curClusPage=" + curClusPage);
				//trace("clusters.length=" + clusters.length);
				if (curPosition <= 0)
				{
					navPrevClus.visible = false;
					return;
				}
				
				//setAllNotVisible();

				//assignClusPage();
				
				//layoutAllClusters();
				
				cls[calcLeftestIndex()].visible = true;

				parMoveLeft.end();
				parMoveRight.end();
				
				curPosition--;
				
				parMoveRight.play();
				
				if (!navNextClus.visible)
				{
					navNextClus.visible = true;
				}
				
				if (curPosition <= 0)
				{
					navPrevClus.visible = false;
				}
			}
			
			private function showNextClusPage():void
			{
				//trace("SearchView.showNextClusPage() begin");
				//trace("curClusPage=" + curClusPage);
				//trace("clusters.length=" + clusters.length);
				if (clusters.length - curPosition <= ncMost)
				{
					navNextClus.visible = false;
					return;
				}
				
				//setAllNotVisible();
				
				//assignClusPage();
				
				//layoutAllClusters();
				
				cls[calcRightestIndex()].visible = true;
				
				parMoveLeft.end();
				parMoveRight.end();
				
				curPosition++;
				
				parMoveLeft.play();
				
				if (clusters.length - curPosition <= ncMost)
				{
					navNextClus.visible = false;
				}
				
				if (!navPrevClus.visible)
				{
					navPrevClus.visible = true;
				}
				
				
			}
			
			private function showPrevPicPage():void
			{
				if (picPage > 0)
				{
					if (rbtnColor.visible && rbtnColor.selected)
					{
						searchRO.getPicUrlForColorRank(null, --picPage, selectedPic);
						disableApplication();
					}
					else if (rbtnWavelet.visible && rbtnWavelet.selected)
					{
						searchRO.getPicUrlForWaveLetRank(null, --picPage, selectedPic);
						disableApplication();
					}
					else if (rbtnRandom.visible && rbtnRandom.selected)
					{
						searchRO.getPicUrlForTagsRandom(getTagNames(clusters[calcDataIndex(selectedClusterIndex)].tagList), tagsSearched, --picPage);
						disableApplication();
					}
					else
					{
						searchRO.getPicUrlForTagsRandom(getTagNames(clusters[calcDataIndex(selectedClusterIndex)].tagList), tagsSearched, --picPage);
						disableApplication();
					}
				}
			}
			
			private function showNextPicPage():void
			{
				if (rbtnColor.visible && rbtnColor.selected)
				{
					searchRO.getPicUrlForColorRank(null, ++picPage, selectedPic);
					disableApplication();
				}
				else if (rbtnWavelet.visible && rbtnWavelet.selected)
				{
					searchRO.getPicUrlForWaveLetRank(null, ++picPage, selectedPic);
					disableApplication();
				}
				else if (rbtnRandom.visible && rbtnRandom.selected)
				{
					searchRO.getPicUrlForTagsRandom(getTagNames(clusters[calcDataIndex(selectedClusterIndex)].tagList), tagsSearched, ++picPage);
					disableApplication();
				}
				else
				{
					searchRO.getPicUrlForTagsRandom(getTagNames(clusters[calcDataIndex(selectedClusterIndex)].tagList), tagsSearched, ++picPage);
					disableApplication();
				}
			}	
			
			private function getTagNames(ar:ArrayCollection):ArrayCollection
			{
				var re:ArrayCollection = new ArrayCollection();
				for (var i:int=0; i<ar.length; i++)
				{
					re.addItem(ar[i].tagName);
				}
				return re;
			}
			
			private function onSearchClick():void
			{
				var words:String = inputTag.text;
				if (words.length == 0)
				{
					return;
				}
				var ts:Array = words.split(/\s+/);
				if (ts.length == 0)
				{
					return;
				}
				viewTags(ts, 6);
				inputTag.text = "";
			}
			
			private function onRestartClick():void
			{
				gameStart();
			}
			
			
			private function radioChange(event:ItemClickEvent):void
			{
				picPage=0; 
				
				var label:String = event.label;
				if (label == "color")
				{
					imgSelected.blendMode=BlendMode.NORMAL;
					searchRO.getPicUrlForColorRank(null, picPage, selectedPic);
					disableApplication();
				}
				else if (label == "wavelet")
				{
					imgSelected.blendMode=BlendMode.NORMAL;
					searchRO.getPicUrlForWaveLetRank(null, picPage, selectedPic);
					disableApplication();
				}
				else
				{
					imgSelected.blendMode=BlendMode.OVERLAY;
					searchRO.getPicUrlForTagsRandom(getTagNames(clusters[calcDataIndex(selectedClusterIndex)].tagList), tagsSearched, picPage);
					disableApplication();
				}
				imgSelected.visible = false;
				imgSelected.visible = true;
			}
			
			// cluster click handler
			private function clusterClickHandler(event:ClusterClickEvent):void
			{
				switch (event.detailTarget)
				{
				case ClusterClickEvent.MORE_TARGET:
					//showBiggerCluster(event.index);
					// do nothing now.
					break;
				case ClusterClickEvent.TAG_TARGET:
					viewTag(String(event.data), event.index);
					break;
				case ClusterClickEvent.VACANCY_TARGET:
				case ClusterClickEvent.PIC_TARGET:
					doSearchClusters(event.index);
					break;
				}
			}
			
			// cluster click handler
			private function leftClusterClickHandler(event:ClusterClickEvent):void
			{
				switch (event.detailTarget)
				{
				case ClusterClickEvent.TAG_TARGET:
					viewTag(String(event.data), selectedClusterIndex);
					break;
				}
			}
		]]>
	</mx:Script>
	
	<mx:RemoteObject id="searchRO" destination="dataQuery_SearchService"
		fault="faultHandler(event)" showBusyCursor="true"/>

	<mx:NumberValidator id="vldTopK" source="{txtTopKInSelectTag}" property="text"/>

	<mx:VBox width="100%" height="100%" styleName="colorPanel">
		<!-- search input area -->
		<mx:HBox width="100%" height="248">
			<mx:VBox id="canSelected" width="236" height="100%" horizontalAlign="center">
				<mx:Image id="imgLogo" width="100%" height="50" 
					source="@Embed('assets/logo.gif')" maintainAspectRatio="false"/>
				<mx:Canvas width="100%" height="100%" borderStyle="solid"
					dragEnter="doDragEnter(event);"
					dragDrop="doDragDrop(event);">
					<mx:Image id="imgSelected" source="assets/mondorana.jpg" width="100%" height="100%"
						verticalAlign="middle" horizontalAlign="center"
						rollOverEffect="{glowImage}" 
	            		rollOutEffect="{unglowImage}"
						completeEffect="Fade"/>
				</mx:Canvas>
				<mx:HBox width="100%" height="21" horizontalAlign="center">
					<mx:RadioButtonGroup id="feature" itemClick="radioChange(event)"/>
					<mx:RadioButton label="color" groupName="feature" selected="false" enabled="false"
						id="rbtnColor"/>
					<mx:RadioButton label="wavelet" groupName="feature" selected="false" enabled="false"
						id="rbtnWavelet"/>
					<mx:RadioButton label="clear" groupName="feature" selected="false" enabled="false"
						id="rbtnRandom"/>
				</mx:HBox>
			</mx:VBox>
			<mx:Spacer width="10"/>
			<!-- input text & tag relation graph-->
			<mx:VBox width="850" height="100%">
				<mx:Spacer height="8"/>
				<mx:Canvas width="100%">
					<mx:Label text="Tags:" y="2" styleName="label" x="6"/>
					<mx:TextInput id="inputTag" width="189" x="47"/>
					<mx:Label text="TopK:" x="249" styleName="label" y="2"/>
					<mx:TextInput id="txtTopKInSelectTag" text="{topKInSelectTag}" x="292" width="65" />
					<mx:Label text="Cluster:" x="362" styleName="label" y="2"/>
					<mx:TextInput id="txtMaxClusterNum" text="{maxClusterNum}" x="416" width="60" />
					<mx:CheckBox id="chkIsExpansion" selected="{isExpansion}" label="Expansion" x="488" width="86"  y="3"/>
					<mx:CheckBox id="chkIsCluster" selected="{isCluster}" label="Cluster" x="579" width="68"  y="3"/>
					<mx:Button label="Search" x="676" width="64" click="onSearchClick();"/>
					<mx:Button label="Restart" x="749" width="64" click="onRestartClick();"/>
				</mx:Canvas>
				<mx:Canvas id="canCluster" width="100%" height="100%" styleName="relationCanvas"
					horizontalScrollPolicy="off" verticalScrollPolicy="off">
					<!-- pages -->
					<hisa:NavButton source="{ICON_LEFT}" 
						id="navPrevClus"
						toolTip="Previous Page"
						imgWidth="12" imgHeight="12"
						x="0" y="125"
					    click="showPrevClusPage()" />
					<hisa:NavButton source="{ICON_RIGHT}" 
						id="navNextClus"
						toolTip="Next Page"
						imgWidth="12" imgHeight="12"
						x="823" y="125"
					    click="showNextClusPage()" />
					<!--clipContent="false"-->
					<mx:Repeater id="rpHrs" dataProvider="{sHrs}">
						<mx:HRule id="hrs" rotation="{rpHrs.currentItem.r}" visible="false"/>
					</mx:Repeater>
					
					<mx:Repeater id="rpCls" dataProvider="{sCls}">
						<hisa:TagCluster id="cls" index="{rpCls.currentIndex}"
							clusterClick="clusterClickHandler(event)"
							styleName="clusterCanvas" visible="false" hasPics="true"
							useHandCursor="true" buttonMode="true"/>
					</mx:Repeater>
						
					<!--
					<hisa:Tag id="tagCenter" x="293.5" y="102" text="TagCenter" visible="false"/>
					-->
					<hisa:TagCluster id="clusCenter" index="6"
						clusterClick="clusterClickHandler(event)" styleName="clusterCanvasCircle" />	
		        </mx:Canvas>
			</mx:VBox>
		</mx:HBox>

		<!-- image view -->
		<mx:HBox width="100%" height="100%" verticalAlign="middle" borderStyle="solid">
			<hisa:TagCluster id="clsWhole" index="100"
					visible="true" hasPics="true"
					clusterClick="leftClusterClickHandler(event)"
					width="210" height="100%" styleName="clusterCanvasWhole" />
			<hisa:NavButton source="{ICON_LEFT}"
				id="navPrevPic"
				toolTip="Previous Page"
				imgWidth="12" imgHeight="12"
			    click="showPrevPicPage()" />

			<!-- image view -->
			<hisa:ImageView id="imgView" width="100%" height="100%"/>

			<hisa:NavButton source="{ICON_RIGHT}"
				id="navNextPic"
				toolTip="Next Page"
				imgWidth="12" imgHeight="12"
			    click="showNextPicPage()" />
		</mx:HBox>
	</mx:VBox>
	
	<mx:Glow id="glowImage" duration="500" 
        alphaFrom="1.0" alphaTo="0.3" 
        blurXFrom="0.0" blurXTo="20.0" 
        blurYFrom="0.0" blurYTo="20.0" 
        color="0xff8000"/>
    <mx:Glow id="unglowImage" duration="500" 
        alphaFrom="0.3" alphaTo="1.0" 
        blurXFrom="20.0" blurXTo="0.0" 
        blurYFrom="20.0" blurYTo="0.0" 
        color="0xffb000"/>

            
    <mx:Dissolve id="dissolveOut" duration="500" alphaFrom="1.0" alphaTo="0.0"/>
    <mx:Dissolve id="dissolveIn" duration="500" alphaFrom="0.0" alphaTo="1.0" target="{clusCenter}" />	
    
    <!-- expand one cluster	-->
    <mx:Parallel id="expandClusBig" duration="500">
        <mx:Move id="moveExClusBig" />
        <mx:Resize id="resExClusBig" />
    </mx:Parallel>

	<!-- contract one cluster -->
    <mx:Parallel id="contractClusBig" duration="300">
        <mx:Move id="moveConClusBig"/>
        <mx:Resize id="resConClusBig"/>
    </mx:Parallel>
    
</mx:Canvas>
